function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
import * as mobx from 'mobx';
import { toJS } from 'mobx';
import { useState } from 'react';
import { AsyncValue } from "./helpers/AsyncValue";
import { Field, FormModel } from "./model";
function isNumericKey(key) {
  return String(Number.parseInt(key)) === key;
}
export function keyToValueShape(key) {
  return isNumericKey(key) ? 'array' : 'object';
}
export function splitToPath(name) {
  return String(name).split('.');
}

/** 合并两个值，如果第一个不为 undefined，则使用第一个值，否则使用第二个值 */
export function composeValue(first, second) {
  if (first !== undefined) {
    return first;
  }
  return second;
}

/** lodash.get(...) for mobx observables */
export function observableGetIn(obj, key, defaultValue) {
  var path = Array.isArray(key) ? key : splitToPath(key);
  var target = obj;
  for (var i = 0; i < path.length; i += 1) {
    if (!mobx.isObservable(target)) {
      return defaultValue;
    }
    target = mobx.get(target, path[i]);
  }
  if (target === undefined) {
    return defaultValue;
  }
  return target;
}

/** lodash.set(...) for mobx observables */
export function observableSetIn(obj, key, value) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  var path = Array.isArray(key) ? key : splitToPath(key);
  var lastPartIndex = path.length - 1;
  var target = obj;
  for (var i = 0; i < lastPartIndex; i += 1) {
    var part = path[i];
    if (mobx.get(target, part) == null) {
      if (isNumericKey(path[i + 1])) {
        mobx.set(target, part, []);
      } else {
        mobx.set(target, part, {});
      }
    }
    target = mobx.get(target, part);
    if (!mobx.isObservable(target)) {
      return;
    }
  }
  if (mobx.isObservable(target)) {
    mobx.set(target, path[lastPartIndex], value);
  }
}
function generateRandomId(len) {
  var byteToHex = function byteToHex(byte) {
    return ('0' + byte.toString(16)).slice(-2);
  };
  var arr = new Uint8Array(len / 2);
  window.crypto.getRandomValues(arr);
  return Array.from(arr, byteToHex).join('');
}
export function useHtmlIdPrefix(htmlIdPrefixProp) {
  var _useState = useState(function () {
      return "xform_".concat(generateRandomId(6), ".");
    }),
    _useState2 = _slicedToArray(_useState, 1),
    autoGeneratedPrefix = _useState2[0];
  if (htmlIdPrefixProp !== undefined) {
    return htmlIdPrefixProp;
  }
  return autoGeneratedPrefix;
}
export function asCSSLength(len) {
  return typeof len === 'number' ? "".concat(len, "px") : len;
}
export function isFalsyOrEmptyArray(value) {
  return !value || Array.isArray(value) && value.length === 0;
}
export var range = function range(n) {
  var result = [];
  for (var i = 0; i < n; i++) {
    result.push(i);
  }
  return result;
};
export function pick(obj, keys) {
  var result = {};
  keys.forEach(function (key) {
    if (key in obj) {
      result[key] = obj[key];
    }
  });
  return result;
}
export function convertWatchableToExpression(watch, model) {
  if (typeof watch === 'string') {
    return function () {
      return toJS(model.getValue(watch));
    };
  } else if (typeof watch === 'function') {
    return watch;
  } else if (watch instanceof Field) {
    return function () {
      return watch.value;
    };
  } else if (watch instanceof FormModel) {
    return function () {
      return toJS(watch.values);
    };
  } else if (watch instanceof AsyncValue) {
    return function () {
      return watch.current;
    };
  } else if (Array.isArray(watch)) {
    return function () {
      return watch.map(function (t) {
        if (typeof t === 'string') {
          return toJS(model.getValue(t));
        } else if (t instanceof AsyncValue) {
          return t.current;
        } else if (t instanceof Field) {
          return t.value;
        } else if (t instanceof FormModel) {
          return toJS(t.values);
        }
      });
    };
  } else {
    console.warn('[xform] 无法识别的 watch 参数', watch);
  }
}